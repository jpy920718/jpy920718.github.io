<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布自己的npm包]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. npmjs.com 注册账号2. 初始化项目123$ mkdir jpy-test-package$ cd jpy-test-package$ npm init 3. 代码12345function jpyPackageDemo () &#123; console.log('test first npm package!');&#125;module.exports = jpyPackageDemo(); 4. 发布12345$ npm login...$ npm publish 5. 更新 更改源代码 12345function jpyPackageDemo () &#123; console.log('test first npm update package!');&#125;module.exports = jpyPackageDemo(); 更新至npm npm version : patch, minor, major(补丁，小改，大改) 12npm version minornpm publish 参考]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat连接Mysql8时出现2059错误解决方法]]></title>
    <url>%2F2019%2F02%2F20%2FNavicat%E8%BF%9E%E6%8E%A5Mysql8%E6%97%B6%E5%87%BA%E7%8E%B02059%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Docker下安装Mysql 当使用低版本的navicat链接mysql8+版本是 会出现2509的错误，原因是因为mysql8+之后使用的caching_sha2_password验证方式，而之前的mysql版本中加密规则是mysql_native_password。解决方法就是将验证方式改为以前版本(5.7及以下)使用的验证方式mysql_native_password windows： 1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; Mac： 123ALTER user 'root'@'%' IDENTIFIED BY '123456' PASSWORD EXPIRE NEVER;ALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456’;FLUSH PRIVILEGES; ‘root’可以改为你自己定义的用户名，’localhost’指的是该用户开放的IP，可以是’localhost’(仅本机访问，相当于127.0.0.1)，可以是具体的’...‘(具体某一IP)，也可以时’%’(所有IP均可访问)。password = 你设置的密码 参考：https://blog.csdn.net/qq_35436635/article/details/80126029]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker下安装mysql]]></title>
    <url>%2F2019%2F02%2F20%2FDocker%E4%B8%8B%E5%AE%89%E8%A3%85Mysql%2F</url>
    <content type="text"><![CDATA[假设已经安装过docker docker 查找镜像1docker search mysql docker 拉取镜像12docker pull mysql // 安装最新mysqldocker pull mysql:8.0.13 // 安装指定版本 docker 查看本地镜像列表1docker images docker 启动mysql 1docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 出现如上图的错误，通过错误提示，刚刚设置的容器名已存在，删除或重命名，选择删除！！！ docker 删除容器 列出容器列表 1docker ps -a // 列出所有容器列表包括未运行的 或者直接查看容器id 1docker ps -a -q // 列出所有容器id 删除docker rm：删除一个或多少容器docker rm [OPTIONS] CONTAINER [CONTAINER.] -f :通过SIGKILL信号强制删除一个运行中的容器 -l :移除容器间的网络连接，而非容器本身 -v :-v 删除与容器关联的卷 1docker rm -f 72d8c2388a8c 在执行查看列表命令 1docker ps -a -q 此时容器已被删除，再去执行启动mysql的命令 1docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 启动成功 进入容器1docker exec -it mysql bash 登录mysql1mysql -u root -p 控制台docker安装mysql和连接mysql完成。 如果使用navicat 连接mysql会出现客户端连接不上的问题解决方法 降低mysql版本低于8 查看下一遍文章可看到解决问题]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Mysql</tag>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Typescript类]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%AD%A6%E4%B9%A0Typescript%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[es5的类es5中定义一个简单的类123456function Person()&#123; this.name='jpy'; this.age=18;&#125;let person = new Person();console.log(person.name); 构造函数和原型链中增加方法1234567891011121314151617function Person()&#123; this.name='jpy'; this.age=18; this.run = function()&#123; console.log(`$&#123;this.name&#125;在走路`) &#125;&#125;let person = new Person();person.run();// jpy在走路// 在原型链上定义属性和方法，Person.prototype.sex = '男';Person.prototype.work = function()&#123; console.log(`$&#123;this.name&#125;在工作`)&#125;person.work();// jpy在工作 原型链上的属性和方法会被多个实例共享但是构造函数不会 类中的静态方法123456789function Person()&#123; this.name='jpy'; this.age=18;&#125;Person.getInfo = function()&#123; return `姓名：$&#123;Person.name&#125;`&#125;Person.getInfo();//姓名：jpy 继承 原型链+对象冒充的组合继承模式.对象冒充继承可以继承Person构造函数里面的属性和方法，但是不能继承Person原型链上的属性和方法原型链继承可以继承Person的构造函数的属性和方法，也能继承原型链上的方法，但是实例化子类时无法给父类传参。12345678function Web()&#123; Person.call(this);//对象冒充实现继承&#125;var w = new Web()w.run();//可以继承Person里面的属性和方法，但是不能继承Person原型链上的属性和方法w.work();// console.error( 12345678 function Web()&#123; Person.call(this);//对象冒充实现继承 &#125;// 原型链实现继承 web.prototype = new Person(); w.run();//ok w.work();//ok 原型链+构造函数的组合继承12345function Web()&#123; Person.call(this, name, age); //对象冒充可以继承Person构造函数里面的属性和方法，但是不能继承Person原型链上的属性和方法&#125;Web.prototype = new Person();var w = new Web('张三', 22); 另一种写法 直接继承父类的原型链123456 function Web()&#123; Person.call(this, name, age); //对象冒充可以继承Person构造函数里面的属性和方法，但是不能继承Person原型链上的属性和方法&#125;Web.prototype = Person.prototype;var w = new Web('张三', 22);w.run(); ts中类通过class 关键字来定义123456789101112class Person&#123; name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): void&#123; console.log(`$&#123;this.name&#125;在跑步`) &#125;&#125;var p = new Person('张三')；p.run(); 1234567891011121314151617181920212223 class Person&#123; name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): void&#123; console.log(`$&#123;this.name&#125;在跑步`) &#125; getName():string&#123; return this.name; &#125; setName(name:string):void&#123; this.name = name &#125;&#125;var p = new Person('张三')；p.getName(); // '张三'p.setName('李四')；p.getName();//‘李四’ ts中实现继承 通过extends、super123456789101112131415161718192021222324 class Person&#123; name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;let p = new Person('王五')p.run();//王五在跑步//开始实现继承, 在构造函数里使用superclass Web extends Person&#123; |constructor(name：string)&#123; super(name);//初始化父类的构造函数 &#125;&#125;let w = new Web('李四')w.run();//李四在跑步 ts中继承的探讨123456789101112131415161718192021222324252627//父类class Person&#123; name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;//子类class Web extends Person&#123; |constructor(name：string)&#123; super(name);//初始化父类的构造函数 &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步--子类` &#125; work():string&#123; return `$&#123;this.name&#125;在工作--子类` &#125;&#125;let w = new Web('李四')；w.run();//李四在跑步--子类w.work();//李四在工作--子类 当子类中的方法与父类的方法相同时执行子类的方法 ts类里的修饰符，在typescript 里定义属性时有三总修饰符 public protected privatepublic：公有 在类里面、 子类里、 类外面都可以访问类里面访问公有属性12345678910111213class Person&#123; public name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;var p = new Person('张三')；p.run();//张三在跑步 子类中访问公有属性123456789101112131415161718192021class Person&#123; public name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;class Web extends Person&#123; constructor(name:string)&#123; super(name) &#125; work(): string&#123; return `$&#123;this.name&#125;在工作` &#125;&#125;let w = new Web('李四');w.work();// 李四在工作 在类外面访问公有属性12345678910111213class Person&#123; public name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;let p = new Person('哈哈');console.log(p.name); //哈哈 protected: 保护类 在类里面可以方位、 子类里面可以访问，但是在类外面是不可以访问的类里面访问保护protected属性12345678910111213class Person&#123; protected name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;var p = new Person('张三')；p.run();//张三在跑步 子类中访问保护protected属性123456789101112131415161718192021class Person&#123; protected name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;class Web extends Person&#123; constructor(name:string)&#123; super(name) &#125; work(): string&#123; return `$&#123;this.name&#125;在工作` &#125;&#125;let w = new Web('李四');w.work();// 李四在工作 在类外面访问保护protected属性12345678910111213class Person&#123; protected name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;let p = new Person('哈哈');console.log(p.name); //error，编译为es5没有问题但在ts中是错误的 private:私有类 在类里面可以访问，但是在子类、类外面是不可以访问的类里面访问私有private属性12345678910111213class Person&#123; private name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;var p = new Person('张三')；p.run();//张三在跑步 子类中访问私有private属性123456789101112131415161718192021class Person&#123; private name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;class Web extends Person&#123; constructor(name:string)&#123; super(name) &#125; work(): string&#123; return `$&#123;this.name&#125;在工作` &#125;&#125;let w = new Web('李四');w.work();// error 编译为es5没有问题但在ts中是错误的 在类外面访问私有private属性12345678910111213class Person&#123; private name: string; //属性， 省略了public关键词 constructor(name: string)&#123; //构造函数 实例化类的时候触发的方法 this.name = name; &#125; run(): string&#123; return `$&#123;this.name&#125;在跑步` &#125;&#125;let p = new Person('哈哈');console.log(p.name); //error，编译为es5没有问题但在ts中是错误的 定义属性时未加修饰符时，默认为public]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Typescript函数]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%AD%A6%E4%B9%A0Typescript%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数定义指定返回类型123456789101112131415161718192021222324//1函数声明法 function fun():string&#123; return 'run'; &#125;//2匿名函数法 let fun = function():string&#123; return '123' &#125;// 没有返回值 function fun():void&#123; console.log('123'); &#125;/*-----------*/// 定义方法传参 function fun(name:string, age: number): string&#123; return `$&#123;name&#125;---$&#123;age&#125;`; &#125; fun('jpy', 27); //right fun('jpy', '27'); //fail let getInfo = function(name: string,age:number):string&#123; return `$&#123;name&#125;---$&#123;age&#125;` &#125; ts中实参和形参必须一样，如果不一样需要配置可选参数,形参后面通过？来决定蚕食是否必传，如果有？则为可选参数，如果没有必传。 注：可选参数必须配置到参数的最后面 123456789function getInfo(name: string, age?: number): string&#123; if(age)&#123; return `$&#123;name&#125;---$&#123;age&#125;` &#125;else&#123; return `$&#123;name&#125;` &#125;&#125;getInfo('jpy', 12);getInfo('jpy'); ts 默认参数，在es5中是无法设置默认参数的，es6之后和ts中可以设置默认参数12345function getInfo(name: string, number=20):string&#123; return `$&#123;name&#125;---$&#123;age&#125;`&#125;getInfo('jpy');getInfo('jpy', 32) 剩余参数1234567891011121314// ...三点运算符function sum(...result: number[]): number&#123; let sum = 0 ; result.map(item =&gt; sum+=item) return sum;&#125;sum(1,2,3) //6//或者function sum(a: number, ...result: number[]): number&#123; let sum = a ; result.map(item =&gt; sum+=item) return sum;&#125;sum(1,2,3)//6 ts函数重载 。Java中函数重载，两个或者以上的函数名相同，但参数不同的函数叫做重载；typescript为了兼容es5以及es6重载的写法和java有区别。 在es5中出现同名的方法，后面的会替换前面的方法。ts中的重载，同样的方法，传入不同参数，执行不同的功能 1234567891011121314function getInfo(name: string):string;function getInfo(age:number):numberfunction getInfo(str:any):any&#123; if(typeof str === 'string')&#123; return `名字：$&#123;str&#125;`; &#125; else if(typeof str === 'number')&#123; return `年龄：$&#123;str&#125;`; &#125; else &#123; throw new Error('类型错误') &#125;&#125;getInfo('jpy');//rightgetInfo(18);//rightgetInfo(true);//fail 以上ts代码经过编译后会变成如下 123456789function getInfo(str)&#123; if(typeof str === 'string')&#123; return `名字：$&#123;str&#125;`; &#125; else if(typeof str === 'number')&#123; return `年龄：$&#123;str&#125;`; &#125; else &#123; throw new Error('类型错误') &#125;&#125; 箭头函数 this指向上下文123setTimeout(()=&gt;&#123; console.log(111);&#125;)]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Typescript类型]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%AD%A6%E4%B9%A0Typescript%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Typescript 数据类型 boolean number string array null 和 undefined tuple enum any void nerver boolean1234// booleanlet bool = true; // 错误let bool: boolean = true; //正确 number1234//numberlet num = 321; // 错误let num: number = 321; // Right string1234//stringlet str = 'jpy'; // Faillet str:string = 'jpy'; // right array ts中定义数组有三种种方式12345678910//arraylet arr = [1,2,3,4,5];// fail//定义数组并且指定数组里的元素都是number类型//第一种let arr:number[]= [1,2,3,4]; //right//第二种let arr:Array&lt;number&gt; = [1,2,3,4];// right// 第三章let arr:any[] = [1,'32',true,34]; //right undefined 和 null12345678//undefinedlet num: number | undefined;console.log(num); //undefinednum = 123;console.log(num); //123//null 一个元素可能是number 可能是null 可能是 undefinedlet num: number | null | undefined; 元祖类型（tuple）属于数组的一种，定义一个数组里元素要么可以是number又可以是string这时候就可以用元祖类型,给数组中每一个元素指定类型。123// Tuplelet arr:[number,string] = [1,'233']; //rightlet arr:[number,string] = [11, 33]; //fail enum 枚举类型 通过使用自然语言中含义清楚的单词来表示它的每个值，这种方法叫做枚举方法，用这种方法定义的类型叫做枚举类型写法： 123456enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数],&#125; 12345678910111213141516// enumenum Type &#123; success=1, error=-1,&#125;;let result:Type = Type.successconsole.log(result) // 1//enum Color&#123; red, origin, blue&#125;let c: Color = Color.blue;console.log(c); //2 如果标识符没有赋值，它的值就是下标 any 任意类型123let num: any = 123; //rightnum = '123'; //rightnum = true; //right void 没有任何类型 一般用于定义方法没有返回值12345678910111213// 方法没有返回任何类型function func():void&#123; console.log(123);&#125;// 下面是错误写法function func(): number&#123; console.log(123);//fail&#125;function fuc(): undefined&#123; console.log(123);//fail&#125; nerver 从不会出现的值 是其他类型的子类型包括null和undefined; 一般不会使用。12345678//nerverlet a:nerver;a = 123;// fail//正确a = (() =&gt; &#123; throw new Error('错误')；&#125;)]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地分支被删如何快速恢复]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E8%A2%AB%E5%88%A0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[本地分支被删如何快速恢复 列之前所有的commit 1$ git log -g 记录查找到的commit_id号 1$ git branch 分支名 commit_id 切换到刚刚的分支名查看 1$ git checkout 分支名]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学学小程序之--小程序模板及include和import的区别]]></title>
    <url>%2F2019%2F01%2F22%2F%E5%AD%A6%E5%AD%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B--%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF%E5%8F%8Ainclude%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[小程序中模板的定义name 模板的名称is声明使用哪个模板，通过data向模板传入信息，只能通过data传入 12345678910111213141516171819// index.wxml&lt;template name="tempItem"&gt; &lt;view&gt; &lt;view&gt;收件人：&#123;&#123;name&#125;&#125;&lt;/view&gt; &lt;view&gt;联系方式：&#123;&#123;phone&#125;&#125;&lt;/view&gt; &lt;view&gt;地址：&#123;&#123;address&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is="tempItem" data="&#123;&#123;...info&#125;&#125;"&gt;&lt;/template&gt;//index.jsPage(&#123; data: &#123; info: &#123; name: '张三', phone:'123232323', address: '中国' &#125; &#125;&#125;) 小程序模板引用include和includeinport只会引用template内的的内容，动态的传入数据，is表示引用的模板名称，data表示传入模板的数据, 不要死循环应用模板12345678// index.wxml&lt;import src="a.wxml"&gt;&lt;/import&gt;&lt;template is="a"&gt;&lt;/template&gt;// a.wxml&lt;view&gt; a里的helloword&lt;/view&gt;&lt;template name="a"&gt;a的模板里的helloword！！ &lt;/template&gt; include只会引用除template内容外的内容1234567891011//index.wxml&lt;include src="a.wxml"&gt;&lt;/include&gt;&lt;template is="a"&gt;&lt;/template&gt;//a.wxml&lt;template name='a'&gt; &lt;view&gt;模板内容&lt;/view&gt;&lt;/template&gt;&lt;view&gt; 模板外的内容&lt;/view&gt;]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript 泛型 类型变量 T]]></title>
    <url>%2F2019%2F01%2F07%2FTypescript%20%E6%B3%9B%E5%9E%8B%20%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%20T%2F</url>
    <content type="text"><![CDATA[类型变量：确保输出的返回值与传入的形参的类型一致，它是一种特殊的变量，表示类型不表示值。 123function func&lt;T&gt;(arg: T): T&#123; return arg;&#125; 通过给函数添加了类型变量 T 。T 可以捕获用户传入的类型，使用 T 作为返回值的类型。这样就可以知道发返回值的类型和参数类型是一致的。 把可以适用于多种类型的函数称为泛型函数。 我们可以使用两种方式来使用泛型函数 第一种：明确指定 T 为string类型, 并传递一个string参数给函数 1func&lt;string&gt;('123') 第二种：利用类型推论，编译器根据传入的参数自动确定 T 的类型 12func(123);func('123'); 不一定使用尖括号明确指定传入参数的类型，编译器可以自己判断传入参数的类型，然后将 T 设置为传入参数的类型。如果编译器不能自动的推断出类型的话，只能明确传入 T 的类型。]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
</search>
